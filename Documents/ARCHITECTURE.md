#  DebugMate CLI 아키텍처 상세

이 문서는 **DebugMate CLI**의 시스템 아키텍처를 상세하게 설명하여, 각 구성 요소의 역할과 상호작용 방식을 명확히 합니다.

---

## 1. 개요

DebugMate CLI는 **사용자 인터페이스 계층**, **코어 로직 계층**, **분석 및 파싱 계층**, 그리고 **외부 서비스 통합 계층**으로 구성된 다계층 아키텍처를 가집니다. 이 구조는 구성 요소 간의 독립성을 보장하며, 시스템의 **확장성**과 **유지보수성**을 극대화합니다.

---

## 2. 아키텍처 구성 요소

### 2.1. 사용자 인터페이스 계층 (CLI Agent)

* **파일**: `debug-mate-cli.js`
* **역할**: 사용자 명령어 입력을 처리하는 진입점
* **구현**: `commander.js` 기반 명령어 파싱, 옵션 처리, 도움말 표시
* **주요 기능**:

  * **tmux 통합**: 좌측에 `vi` 편집기, 우측에 AI 분석 결과를 표시하는 대화형 환경 제공.
  * **파일 감시**: `watch-and-debug.sh`와 연동하여 `inotify-tools`로 저장 이벤트를 감지.
  * **환경 설정 관리**: `.env` 파일을 생성/갱신하여 API 키 관리.
  * **의존성 검사/설치**: 필수 도구(`tmux`, `inotify-tools`, `gcc/g++`, `python3`, `make`) 확인 후 설치 안내.

---

### 2.2. 코어 로직 계층 (Core Analysis Engine)

* **파일**: `src/analysis/DebugAgent.ts`
* **역할**: 사용자의 **자연어 요청 해석**과 **분석 모듈 라우팅**을 담당하는 시스템의 두뇌
* **주요 기능**:

  * **의도 파싱**: 한국어 질의를 분석하여 어떤 모듈(`loopCheck`, `traceVar`, `afterDebug`)이 적합한지 결정
  * **분석 라우팅**: 해석된 의도를 기반으로 모듈 호출 및 결과 취합
  * **자연어 오타 처리**: 맞춤법/철자 오류가 포함된 요청도 의도 분석이 가능하도록 설계
  * **AI 호출 최적화**: 캐시 사용 및 토큰 절약용 트리머를 통해 비용 절감

---

### 2.3. 분석 및 파싱 계층 (Analysis & Parsing Modules)

이 계층은 코드 자체 또는 컴파일러 출력물을 전문적으로 분석하는 모듈들로 구성됩니다.

#### 분석 모듈 (`src/analysis/`)

* **beforeDebug.ts**: 저장 직후 코드에 대한 초기 해석 제공
* **afterDebug.ts**: 컴파일/런타임 로그 기반 종합 분석
* **loopCheck.ts**: 반복문 구조 파악 및 무한 루프 가능성 진단
* **traceVar.ts**: 변수 초기화→변경→최종값 추적 (배열/포인터/구조체 포함)

#### 파싱 엔진 (`src/parsing/`)

* **loopExtractor.ts**: 반복문 블록 추출 (주석/문자열 제외)
* **compilerResultParser.ts**: GCC 오류·경고·실행 로그를 구조화
* **codeParser.ts**: 함수명 등 기본 코드 구조 파싱
* **응답 검증 및 파싱 파일**: Gemini API 호출 후 응답을 엄격히 검증하고 구조화된 형태로 파싱하기 위한 전용 모듈 추가

---

### 2.4. 외부 서비스 통합 계층 (External Service Integration)

* **compile.ts (`src/services/`)**

  * GCC 호출 및 실행 담당
  * `-fsanitize`, `-fanalyzer` 등 다양한 GCC 컴파일 옵션을 적용해 가능한 많은 오류를 포착
  * 
* **SGlobal.ts (`src/config/`)**

  * 전역 설정/환경 변수 접근을 통일화
  * dotenv/dotenv-expand로 환경 변수 로딩

---

## 3. 데이터 흐름 및 상호작용

1. **사용자 입력**: CLI(`debug-mate`)를 통해 파일 경로 및 자연어 질의 입력
2. **CLI 에이전트 처리**: tmux 세션 구성, 파일 감시(`watch-and-debug.sh`) 시작
3. **파일 저장 이벤트**: `inotify-tools`가 변경을 감지 → `inprogress-run.ts` 실행
4. **초기 해석 단계**: `beforeDebug.ts`가 즉각 코드 개요와 문제점 요약 출력
5. **심층 분석 요청**: 사용자가 자연어로 요청 → `DebugAgent.ts`가 의도 해석 (오타 교정 포함)
6. **분석 실행**:

   * `afterDebug.ts`: 종합 코드 분석 (컴파일/런타임 로그)
   * `loopCheck.ts`: 루프 조건 분석
   * `traceVar.ts`: 변수 추적
7. **로그 파싱**: `compilerResultParser.ts`가 컴파일/실행 로그를 구조화
8. **AI 분석**: Gemini API 호출 시 캐시, 트리머, 재시도, 타임아웃, 응답 검증 과정을 거쳐 안정적 분석 수행
9. **결과 출력**: tmux 우측 패널에 Result/Reason/Suggestion 형식으로 표시, 필요 시 코드 파일에 주석 추가

---

## 4. 요약

DebugMate CLI의 아키텍처는 **모듈화·계층화**를 통해 각 구성 요소의 역할을 분리했습니다.

* CLI는 직관적인 인터페이스를 제공하고,
* DebugAgent는 자연어 이해와 분석 라우팅을 수행하며,
* 전문 모듈들은 코드와 로그를 정밀 분석합니다.
* 외부 서비스는 GCC와 Gemini API를 통해 실행/AI 분석을 보장합니다.
* 추가적으로 **AI 호출 안정성(재시도, 타임아웃, 응답 검증, 캐시, 트리머)**, **전역 설정 통일화(SGlobal)**, **자연어 오타 보정**을 통해 실사용성을 강화했습니다.

이러한 구조는 **확장성**, **안정성**, **비용 효율성**, **사용자 친화성**을 갖춘 디버깅 경험을 제공합니다.
